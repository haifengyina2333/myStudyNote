## Git
### 版本控制
#### 什么是版本控制？我们为什么要关心它呢？
版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
#### 为什么要使用版本控制?
软件开发中采用版本控制系统是个明智的选择。
有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
#### 集中化的版本控制
集中化的版本控制系统诸如 CVS，svn 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法
![Alt text](img/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png)

这种做法带来了许多好处，现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统; 要远比在各个客户端上维护本地数据库来得轻松容易

**事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。**

**要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险**

####  分布式的版本控制系统
于是分布式版本控制系统面世了。在这类系统中，像 Git，BitKeeper 等，==**客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。**== 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份
![Alt text](img/%E5%88%86%E5%B8%83%E5%BC%8F.png)

更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中分别和不同工作小组的人相互协作。

**分布式的版本控制系统在管理项目时 存放的不是项目版本与版本之间的差异.它存的是索引(所需磁盘空间很少 所以每个客户端都可以放下整个项目的历史记录)**

**分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:**
1. 断网的情况下也可以进行开发(因为版本控制是在本地进行的)
2. 使用 github 进行团队协作,哪怕 github 挂了 每个客户端保存的也都是整个完整的项目(包含历史记录的!!!）

### Git的简介与安装
#### 简介：
Git 是目前世界上最先进的分布式版本控制系统。同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002
年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。

到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：

- 分支切换速度快 
- 容量小(压缩) 
- 简单的设计 
- 完全分布式
- 对非线性开发模式的强力支持（允许上千个并行开发的分支）
- 有能力高效管理类似 Linux 内核一样的超大规模项（速度和数据量）

自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统可以应付各种复杂的项目开发需求。

#### Git的安装
git 地址 : https://git-scm.com/download/win
![Alt text](img/Linux%E5%AE%89%E8%A3%85.png)
安装时，无脑下一步即可

![Alt text](img/GIt%E6%89%93%E5%BC%80.png)

之后需要在Git的命令行界面进行简单的配置：

输入`git  --version ` 可以参考Git的版本号

Git 提供了一个叫做 git config 的命令来配置或读取相应的工作环境变量而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：

` /etc/gitconfig ` 文件：系统中对所有用户都普遍适用的配置。若使用 ` git config ` 时用 `  --system ` 选项，读写的就是这个文件。

` ~/.gitconfig  `文件：用户目录下的配置文件只适用于该用户。若使用 `git config `时用 ` --global `选项，读写的就是这个文件。

` .git/config `文件：当前项目的 Git 目录中的配置文件（也就是工作目录中的 ` .git/config `文件）这里的配置仅仅针对当前项目有效。

**用户信息 :**
第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：
```
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
```
要检查已有的配置信息，可以使用 
`git config --list `

删除配置信息
`git config --global --unset user.email`

#### 区域
工作区
暂存区（索引）
版本库

工作区的内容修改好，改好之后提交到暂存区，此时会形成一个版本

#### 对象
Git对象
树对象
提交对象

### Git底层命令(底层概)
#### 初始化Git仓库
要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行： `git init `

**作用：** 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。

#### linux命令
`clear` ：清除屏幕
`echo 'test content'` ：往控制台输出信息 
`echo 'test content' > test.txt` 往 test.txt 里输入test content ,没有则是新建
`ll `：将当前目录下的 子文件&子目录平铺在控制台
`find 目录名`： 将对应目录下的子孙文件&子孙目录平铺在控制台
`find 目录名 -type f `：将对应目录下的文件平铺在控制台
`rm 文件名 `： 删除文件
`mv 源文件 重命名文件`: 重命名
`cat 文件的 url `: 查看对应文件的内容
`vim 文件的 url(在英文模式下)` 即可查看文件
> 按 i 进插入模式 进行文件的编辑 
 按 esc 键之后按 `:`键 进行以下命令的执行
 q! 强制退出（不保存）
 wq 保存退出
 set nu 设置行号

#### Git对象
Git 的核心部分是一个简单的键值对数据库。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容

##### 向数据库写入内容并返回对应键值

**命令：** `echo 'test content' | git hash-object -w --stdin`
写入的内容被压缩处理了。

**返回：**
该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值

**其他说明：**
`-w `  选项指示 hash-object 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值(哈希值),不存储数据。
存储在git的目录下的object文件夹

` --stdin `（standard input）选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径,也就是说没有前面的echo命令，则需要跟文件路径。

存文件 : `git hash-object -w 文件路径 `
返回对应文件的键值: `git hash-object 文件路径 `
 
##### 查看 Git 是如何存储数据的 
**命令：** 
`find .git/objects -type f `

**返回：** 
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 

##### 根据键值拉取数据 

**命令：** 
`git cat-file -p key `

-p 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容
利用 cat-file -t 命令，可以让 Git 告诉我们其内部存储的任何对象类型

**返回：**
对应文件的内容


##### 对一个文件进行简单的版本控制 

创建一个新文件并将其内容存入数据库 
**命令：**
```
echo 'version 1' > test.txt 
git hash-object -w test.txt 
```
**返回：** 
`83baae61804e65cc73a7201a7252750c76066a30`

向文件里写入新内容，并再次将其存入数据库 
**命令：** 
```
echo 'version 2' > test.txt 
git hash-object -w test.txt 
```
**返回：** 
`1f7a7a472abf3dd9643fd615f6da379c4acb3e3a`

查看数据库内容 
命令： 
`find .git/objects -type f `

```
git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 
git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
```

##### 问题：
1. 记住**文件的每一个版本**所对应的 SHA-1 值并不现实
2. 在 Git 中，文件名并没有被保存 —— 我们仅保存了文件的内容
==**解决方案：树对象 **==

**注意:**
当前的操作都是在对本地数据库进行操作不涉及暂存区

##### Git存储的是数据

#### 树对象
树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容。所有内容均以树对象和数据对象(git 对象)的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象(git 对象)则大致上对应文件内容。一个树对象包含了一条或多条记录（每条记录含有一个指向 git 对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息）。一个树对象也可以包含另一个树对象。

我们可以通过 update-index；write-tree；read-tree 等命令来构建树对像并塞入到暂存区。

假设我们做了一系列操作之后得到一个树对像

##### 操作
1. 利用 `  update-index `命令 为 test.txt 文件的首个版本——创建一个
暂存区。并通过 ` write-tree `命令生成树对像。
命令：
`echo "test.txt v1" > test.txt`
`git hash-object -w test.txt`
`git update-index --add --cacheinfo 100644  560a3d89bf36ea10794402f6664740c284d4ae3b test.txt `

` git write-tree  `

文件模式为 
100644，表明这是一个普通文件 
100755，表示一个可执行文件； 
120000，表示一个符号链接。

`--add `选项： 因为此前该文件并不在暂存区中 首次需要`-—add `

`--cacheinfo `选项： 因为将**要添加的文件位于 Git 数据库中**，而不是位于当前目录下 所有需要`-—cacheinfo `
 
**查看暂存区当前的样子**
`git ls-files -s`

2. 新增 new.txt 将 new.txt 和 test.txt 文件的第二个个版本
塞入暂存区。并通过 write-tree 命令生成树对像。
命令： 
```
echo 'new file' > new.txt 
//修改test.txt的内容，使其成为版本v2
git hash-object -w test.txt
```
从目前为止，库里一共是四条记录，即
![Alt text](img/%E5%9B%9B%E4%B8%AA%E5%93%88%E5%B8%8C.png)
第一个是树对象（即项目的一个版本记录）
一个是 test.txt 文件的版本 v1
一个是 test.txt 文件的版本 v2
一个是  new.txt  文件的版本 v1

```
git update-index --cacheinfo 100644 test.txt第二个版本的哈希 test.txt 

git update-index --cacheinfo 100644 new的哈希 new.txt

//git update-index --add new.txt 
git write-tree 
```
![Alt text](img/%E4%BA%94%E4%B8%AA%E8%AE%B0%E5%BD%95.png)
**目前是三个Git对象，两个树对象**
树一：` 06e21bb0105e2de6c846725a9a7172f57dd1af96 `
数二：` fa7df0191ee34ec020a6a4006ea645a5d709d097 `

3. 将第一个树对象加入第二个树对象，使其成为新的树对象
**命令：**
```
git read-tree 
--prefix=bak 第一颗的哈希 
git write-tree 
```
` read-tree ` 命令，可以把树对象读入暂存区

**最后的树：**

![Alt text](img/%E6%9C%80%E5%90%8E%E7%9A%84%E6%A0%91.png)

##### 问题
现在有三个树对象（执行了三次 write-tree），分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。而以上这些，正是提交对象（commit object）能为你保存的基本信息

**查看树对象：**
`git cat-file -p 6ca41ab7f4e217c254a2b9c6988df2b5aaca47f1` 即第三个树的哈希
![Alt text](img/%E6%9F%A5%E7%9C%8B%E6%A0%91%E5%AF%B9%E8%B1%A1.png)

#### 提交对象
我们可以通过调用 commit-tree 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话 第一次将暂存区做快照就没有父对象）

##### 创建提交对象 
` echo 'first commit' | git commit-tree 树一的哈希 `

**返回提交对象的哈希：**
提交对象1: `fdf4fc3344e67ab068f836878b6c4951e3b15f3d`

##### 查看提交对象 
`git cat-file -p fdf4fc33 //提交对象的哈希(前几个哈希文就可以) `

返回：
>一个树对象的哈希
>提交者的名字
>提交者的邮箱
>提交的信息

##### 提交对象的格式
提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的 user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释

接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其
父提交对象）：

`echo 'second commit' | git commit-tree 树2的哈希 -p 提交对象1`
提交对象2: ` cac0cab538b970a37ea1e769cbbde608743bc96d `

`echo 'third commit' | git commit-tree 树3的哈希 -p 提交对象2 `
提交对象3: `1a410efbd13591db07496601ebc7a059dd55cfe9`

![Alt text](img/%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png)

##### 注意 
` git commit-tree `不但生成提交对象 而且会将对应的快照（树对象）提交到本地库中 

#### 总结:
实际上**树对象**保存了文件的对象和其他树对象,而**提交对象**保存了树对象和提交者的信息、上一个提交对象,实际上提交对象才是每个版本的快照和说明。

树对象只是保存了版本快照，但没有保存版本说明。

实际上树对象完整的保留了每个版本的快照，而不是增量的保存，这样虽然付出了更多的空间，但却可以完整的保留所有历史版本。

![Alt text](img/%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png)

### Git高层命令

#### Git操作最基本的流程
1. 创建工作目录: `git init`
2. 对工作目录进行修改 
3. `git add 文件名` 在库生成了Git对象,同时推送到暂存区
   >`git hash-object -w 文件名(修改了多少文件,就被执行了多少次)`
   >`git updata -index --add --cacheinfo 100644 Git的哈希` 
4. `git commit -m "注释内容"` 生成了树对象和提交对象
   >`git write-tree`
   >`git commit-tree 树的哈希 -m "提交的信息"`

#### 初始化新仓库

**命令：** `git init`

**解析：** 要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执
行：` git init `

**作用：**初始化后，在当前目录下会出现一个名为 .git 的目录，**所有 Git 需要的数据和资源都存放在这个目录中**。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。

工作目录下面的所有文件都不外乎这两种状态：**已跟踪 或 未跟踪**

已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是 ==**已提交，已修改或者已暂存**==

所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。

初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为已提交；在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件。使用 Git 时的文件状态变化周期如下图所示


#### 检查当前文件状态
命令：`git status`
作用：确定文件当前处于什么状态

#### 跟踪新文件（暂存区）,将修改添加到暂存区 
**命令：** `git add 文件名`

**作用：** 跟踪一个新文件,实际上是这样子的 > ==**工作区文件 -> 在库中生成Git对象 -> 推送到暂存区**==


#### 查看已暂存和未暂存的更新 
实际上` git status `的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用` git diff `命令.这个命令它已经能解决我们

两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备
好了下次提交？
1. 当前做的哪些更新还没有暂存？，
命令：`git diff`（不加参数直接输入 git diff）
1. 有哪些更新已经暂存起来准备好了下次提交？
命令： ` git diff –cached ` 或者` git diff –staged `(1.6.1 以上)


#### 提交更新 
当暂存区域已经准备妥当可以提交时，在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令` git commit`

命令：`git commit`
注意：这种方式会启动文本编辑器以便输入本次提交的说明

默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。

尽管使用暂存区域的方式可以精心准备要提交的细节，但**有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式**，只要在提交的时候，给` git commit `加上` -a `选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过` git add `步骤,不过要先有跟踪.


`git commit -a` : 将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过 git add 添加到暂存区。

#### 移除文件
要从 Git 中移除某个文件，就必须要从已跟踪文件清单中注册删除（确切地说，是在暂存区域注册删除），然后提交。可以用 ` git rm `命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

这里里的删除不是真的删除，只是**打上已删除的标识而已**，仍然存在于本地仓库中
实际上是同时删除了工作区和暂存区的相关文件。

` git rm ` 此命令只能删除没修改过的文件，实际上相当于 
```
rm 文件名
<!-- 此时会变成以修改，需要提交到暂存区 -->
git add 文件名
<!-- 再去提交 -->
```

`git rm -f 文件名` 文件修改后的删除

`git rm --cached 文件名` 删除暂存区文件，但保留工作区的文件，并且将这次删除放入暂存区。

#### 文件改名 
`git mv 文件名 被修改的文件名` 实际上,修改文件名就相当于删除了老文件，新建了一个文件,一般而言，都需要删除老文件操作一下，同时`add`新文件一下,不过此操作取代了下面的操作，比较简便:
其实，运行 git mv 就相当于运行了下面三条命令：
>mv README.txt  README
git rm README.txt
git add README

#### 查看历史记录

`git log `: 提交历史,默认是五行

在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。
完成这个任务最简单而又有效的工具是 ` git log `命令

**参数:**
` git log --pretty=oneline` 一条一行
` git log --oneline ` 一条一行,但哈希简写

#### 总结

`git init` 初始化仓库
`git status `查看文件的状态
`git diff` 查看哪些修改还没有暂存
`git diff --staged` 查看哪些修改以及被暂存了还没提交
`git log --oneline` 查看提交的历记录
`git add./ ` 将修改添加到暂存区
` git reflog ` **查看仓库所有操作**
将暂存区提交到版本库:
`git commit`
`git commit -a`
`git commit -a -m "注释"`

### Git 分支操作
几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。

而 Git 的分支模型极其的高效轻量的。是 Git 的必杀技特性，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出

#### 创建分支
**命令：** `git branch 分支名`
**作用：**
为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分
支：` git branch testing `。这会在当前所在的提交对象上创建一个指针
 注意：
1. `git branch 分支名` 创建一个新分支，并不会自动切换到新分支中去,搭配`git checkout 分支名` 即可

![Alt text](img/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF.png)

`git branch `不只是可以创建与删除分支。 如果不加任何参数运行它，会得到 **当前所有分支的一个列表**
` git branch -d 分支名` 删除分支，（删除空的分支删除已经被合并的分支） `-D `强制删除
` git branch -v ` 可以查看每一个分支的最后一次提交
` git branch 分支名 commitHash` 新建一个分支并且使分支指向对应的提交对象相当于时光机
>`git branch –merged`
查看哪些分支已经合并到当前分支
在这个列表中分支名字前没有 * 号的分支通常可以使用
`git branch -d` 删除掉

>`git branch --no-merged`
查看所有包含未合并工作的分支
尝试使用` git branch -d `命令删除在这个列表中的分支时会失败。
如果真的想要删除分支并丢掉那些工作，可以使用` -D `选项强制删
除它。

#### 切换分支
 
` git checkout 分支名`
**切回 master 命令：** `git checkout master`

![Alt text](img/%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png)

`-b` 可以创建的同时切换过去 `git checkout -b 分支名`


**注意 :**

==**分支切换会改变你工作目录中的文件，同时缓存区也会被改变**==

在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。同时缓存区也会被改变。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支

==**每次在切换分支前 提交一下当前分支**==
==**每次切换分支前当前分支一定得是干净的（已提交状态）**==

在切换分支时如果当前分支上有未暂存的修改（第一次）或者有未提交的暂存（第一次）
分古可以切换成功 ， 但是这种操作可能会污染其他分古

![Alt text](img/%E4%BF%AE%E6%94%B9%E5%88%86%E6%94%AF%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4.png)


#### 查看项目分叉历史
`git log --oneline --decorate --graph --all` 

以后可以起别名 方便快速输入。


#### 分支合并

![Alt text](img/%E5%90%88%E5%B9%B6%E7%9A%84%E7%9B%AE%E7%9A%84.png)

先切回主分支，执行 `git merge 被合并分支` ,可以将被合并分支的代码合并到主分支。

然后就可以删除被合并分支 `git branch -d 被合并分支`

这种合并称为：快进合并
![Alt text](img/%E5%BF%AB%E8%BF%9B%E5%90%88%E5%B9%B6.png)

#### 分支模式

**长期分支：**
![Alt text](img/%E9%95%BF%E6%9C%9F%E5%88%86%E6%94%AF.png)


#### 分支的本质
Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是` master `。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的` master `分支。 它会在每次的提交操作中自动向前移动。

HEAD是一个指针，默认是指向master分支，切换分支其实就是让HEAD指向不同的分支  每次有新的提交时HEAD都会带着当前指向的分支,一起往前移动

#### 分支原理
`git/refs`  : 这个目录中保存了分支及其对应的提交对象

**HEAD :** 它是一个指向其他引用的指针

### Git存储
当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题就需要Git存储

`git stash `命令会将未完成的修改保存到一个栈(后进先出)上，而你
可以在任何时候重新应用这些改动 `git stash apply`

`git stash apply 名字 ` 如果不指定一个储藏，Git 认为指定的是最近的储藏
` git stash list `:查看存储
` git stash drop 名字` :将要移除的储藏的名字来移除它
`git stash pop 名字` 来应用储藏然后立即从栈上扔掉它

### 配别名
Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。
```
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
```
主要是针对这个
`git config --global alias.XXX "log --oneline --decorate --graph --all"` 太长的用双引号包起来，防止出现 BUG
可以简化为 ` git XXX`

### 撤销（后悔药）

#### 撤销在工作目录的修改
`git checkout --文件名（文件路径） ` ：将在工作目录中对文件的修改撤销

#### 撤销在暂存区的修改
`git reset HEAD(默认的指针) 文件名` ：将文件从暂存区中撤回到工作目录

#### 撤销版本库的修改

**注释信息错误：**
`git commit --amend `  如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息

**提交错误或者是缺失：**
如果你 **提交后发现忘记了暂存某些需要的修改**，可以像下面这样操作
```
git commit -m 'initial commit'
git add ./
git commit –amend
```
最终你只会有一个提交 -> 第二次提交将代替第一次提交的结果

意思就是如果你提交完项目，发现 **有些修改你忘补充了,就把这些修改add到暂存区，然后对上一次的提交进行修订**,可以说amend命令不是撤销提交，而是对提交进行修订（修改注释或者补充修改内容）

本质上是 把旧的错误的隐藏，再次提交，看怎么理解，说是修订也没问题，但是实际上是重新提交了

另外可以直接` git commit -a --amend `,然后改注释，一次到位，当然，**有新文件的话，那还是先单独add**

### Reset重置三部曲（commithash）

==**Reset的命令移动了HEAD，会带着分支一起走**==

移动 HEAD : `git reset –soft HEAD~ ` 
这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。

它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。
当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行` git commit` 来完成 `git commit --amend` 所要做的事情了。

`git reset [--mixed] HEAD~`
`[--mixed] ` ： 不保存暂存区
注意  ` git reset HEAD~  `等同于`  git reset –mixed HEAD~`
:它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有` git add `和 `git commit` 的命令执行之前。

`git reset --hard HEAD~`
你撤销了最后的提交、git add 和 git commit 命令以及工作目录中的所有工作。

必须注意，`--hard `标记是 `reset `命令唯一的危险用法，它也是 Git 会
真正地销毁数据的仅有的几个操作之一。 其他任何形式的` reset `调用都可
以轻松撤消，但是 `--hard `选项不能，因为**它强制覆盖了工作目录中的文件**。
在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版
本，我们可以通过 `reflog `来找回它。**但是若该文件还未提交，Git 仍会覆
盖它从而导致无法恢复。**

**路径reset：**
` git reset 文件名 ` 相当于 是 ` git reset --mixed HEAD 文件名`
撤销暂存区文件的修改，回到上一次提交的文件。

注意点：首先不同于` reset --hard ` , ` checkout ` 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。而 `reset --hard` 则会不做检查就全面地替换所有东西。
第二个重要的区别是如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。
![Alt text](img/reset%20%E5%92%8C%20checkout%E7%9A%84%E5%8C%BA%E5%88%AB.png)

`git checkout -- 文件名 ` 更新工作目录
`git checkout commithash 文件名 ` 更新工作目录和暂存区

### 数据恢复

在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了
正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？

使用`  git reflog `找到了你想恢复到的版本 执行` git branch 分支名 hash `
现在有一个新的的分支是你的 master 分支曾经指向的地方，再一次使得前两次提交可到达了。

或者是执行 ` git reset --hard hash`

### 打Tag(标签名)
#### 列出Tag
`git tag -l '标签名*'`

#### 创建Tag
`git tag 标签名` 默认最新的提交
`git tag v1.4 commitHash` 指定的提交对象


#### 查看标签
`git show 标签名`

#### 删除标签
`git tag -d 标签名`

#### 检出标签
`git checkout 标签名`

这会使你的仓库处于“分离头指针（detacthed HEAD）”状态。在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何 分支，并且将无法访问，除非访问确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错 误,这通常需要创建一个新分支：
`git checkout -b 分支名`

简而言之:检出标签之后如果想做修改,必须创建一个新分支。才能做修改并且提交。


## 远程仓库

### Github仓库的创建
![Alt text](img/Github%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA.png)
![Alt text](img/%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA01.png)
![Alt text](img/%E4%BB%93%E5%BA%9302.png)

### 为远程仓库配置别名和用户信息
`git remote –v`:显示远程仓库使用的 Git 别名与其对应的 URL
`git remote add 仓库别名 url`:添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写

`git config user.name "名字"`
`git config user.email "邮箱"`

`git branch -M main` 改主分支名字为 main

### 推送本地项目到远程仓库
`git push 仓库别名 分支名(一般是main)`

`git push 仓库别名 本地分支名:远程分支名`

### 克隆远程仓库到本地
`git clone url （克隆时不需要 git init）`

### 邀请成员加入团队
![Alt text](img/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE.png)
![Alt text](img/%E9%82%80%E8%AF%B7.png)

### 更新成员提交的内容
`git fetch 别名`
git fetch [remote-name]
这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。

`git merge 分支名` 合并分支



`git pull ` 相当于这里的两个，如果分支产生了冲突了，就还要自己处理
只能在 **远程跟踪分支和本地分支建立联系时使用**


### 远程分支 远程跟踪分支 本地分支 的区别


![Alt text](img/%E8%BF%9C%E7%A8%8B%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF.png)

绿色的是本地分支 红色的是远程跟踪分支  远程分支是仓库的分支

实际上push（fetch）时，是远程跟踪分支同远程分支进行同步，在fetch时，会在本地创建 远程跟踪分支，除了克隆仓库时主分支和远程跟踪分支有联系，其他分支创建时，一般没有联系，这个时候如果在本地分支和远程跟踪分支同步之后，重新提交本地分支，那么就会面临push失败的情况。因为远程跟踪分支和远程分支的版本是一样的。

#### 一个本地分支怎么去跟踪一个远程跟踪分支（联系）
1. 当克隆的时候 会自动生成一个master本地分支(已经跟踪了对应的远程跟踪分支)
2. 在新建其他分支时 可以指定想要跟踪的远程跟踪分支
   ` git checkout -b 本地分支名 远程跟踪分支名`
   ` git checkout --track  远程跟踪分支名 `（这样子是同名的）
3. 将一个已经存在的本地分支 联系 一个远程跟踪分支   
   `git branch -u 远程跟踪分支名   `

**查看已经建立联系的分支:** `git branch -vv`

#### 删除远程分支
`git push origin --delete serverfix`  删除远程分支
`git remote prune origin --dry-run`   列出仍在远程跟踪但是远程已被删除的无用分支
`git remote prune origin `   清除上面命令列出来的远程跟踪


## 冲突

### 本地冲突
合并之后，会在冲突文件内有区域提示，自己打开文件处理，处理完毕之后重新提交一次，完成对冲突的处理。

### 远程冲突
即你在提交之前，有另一个版本提交了，而你刚刚好提交的内容有重复的地方，就重新`pull`一下，找到重复地方，做出修改，再提交一次版本，重新推送。

写一半拉取之后，发现版本落后之后而且有冲突，先提交一次，然后再拉取，做修改，再此提交，然后再推送。


## 派生

如果你想要参与某个项目，但是并没有推送权限，这时可以对这个项目进行“派生”（Fork）。 派生的意思是指，GitHub 将在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。通过这种方式，项目的管理者不再需要忙着把用户添加到贡献者列表并给予他们推送权限。 人们可以派生这个项目，将修改推送到派生出的项目副本中，并通过创建合并请求（Pull Request）来让他们的改动进入源版本库。
基本流程：
1. 从 master 分支中创建一个新分支 （自己 fork 的项目）
2. 提交一些修改来改进项目 （自己 fork 的项目）
3. 将这个分支推送到 GitHub 上 （自己 fork 的项目）
4. 创建一个合并请求
5. 讨论，根据实际情况继续修改
6. 项目的拥有者合并或关闭你的合并请求
注意点：
每次在发起新的 Pull Request 时 要去拉取最新的源仓库的代码而不是自己 fork 的那个仓库。
`git remote add <shortname 源仓库> <url 源仓库>`
`git fetch 远程仓库名字`
`git merge 对应的远程跟踪分支`

## 远程协作
### 三个必须懂得概念
    本地分支
    远程跟踪分支(remote/分支名)
    远程分支

### 远程协作的基本流程
    第一步: 项目经理创建一个空的远程仓库
    第二步: 项目经理创建一个待推送的本地仓库
    第三步: 为远程仓库配别名  配完用户名 邮箱
    第四步: 在本地仓库中初始化代码 提交代码
    第五步: 推送
    第六步: 邀请成员
    第七步: 成员克隆远程仓库
    第八步: 成员做出修改
    第九步: 成员推送自己的修改
    第十步: 项目经理拉取成员的修改

### 做跟踪
    克隆才仓库时 会自动为main做跟踪
    本地没有分支
        git checkout --track 远程跟踪分支(remote/分支名)
    本地已经创建了分支
        git branch -u 远程跟踪分支(remote/分支名)
### 推送
    git push
### 拉取
    git pull
### pull request
    让第三方人员参与到项目中 fork



### 使用频率最高的五个命令
    git status
    git add
    git commit
    git push
    git pull