## 数据容器



**一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素
每一个元素，可以是任意类型的数据，如字符串、数字、布尔等。**

**数据容器可以容纳多份数据**

数据容器根据特点的不同，如：
- 是否支持重复元素
- 是否可以修改
- 是否有序，等

分为5类，分别是:
**列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict)**

### 列表  (==这玩意很像进化版数组==)：

#### 列表的基本语法：**
```python
# 字面量
[1,2,3,4,5,6,7]

# 定义变量
变量名称 = [1,2,3,4,5,6,7]

# 定义空列表
变量名称 = []
变量名称 = list()
```
列表内的 ==**每一个数据，称之为元素**==
- **以[ ]作为标识**
- **列表内每一个元素之间用，逗号隔开**
- **列表可以嵌套**

#### 下标索引：

**列表中的每一个元素，都有其位置下标索引，从前向后的方向，从 0 开始，依次递增**
**可以反向索引，也就是从后向前：从-1开始，依次递减(-1、-2、-3......)**

==**索引超过就报错**==

#### 列表的常用操作：
以外，列表也提供了一系列功能：
- 插入元素
- 删除元素
- 清空列表
- 修改元素
- 统计元素个数

等等功能，这些功能我们都称之为：==**列表的方法**==

在Python中，**如果将函数定义为class（类）的成员，那么函数会称之为：方法**
![Alt text](img/%E5%87%BD%E6%95%B0.png)
![Alt text](img/%E6%96%B9%E6%B3%95.png)

**方法和函数功能一样，有传入参数，有返回值，只是方法的使用格式不同：**
![Alt text](img/%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.png)

**查找某元素的下标：**
功能：查找指定元素在列表的下标，如果找不到，报错ValueError
语法：` 列表.index(元素) `
` index `就是列表对象（变量）内置的方法（函数）

**修改特定位置（索引）的元素值：**
语法：` 列表[下标]=值 `
可以使用如上语法，直接对指定下标（正向、反向下标均可）的值进行：重新赋值（修改）

**插入元素：**
语法：` 列表.insert(下标,元素) `,在指定的下标位置,插入指定的元素
```python
my_list = [1,2,3]
my_list.insert(1, "python")
print(my_list)
# 结果：[1,"python", 3, 4]
```

**追加元素：**
语法： ` 列表.append(元素) `，将指定元素，追加到列表的**尾部**

**追加元素方式2：**
语法：` 列表.exteng(其它数据容器) `，将**其它数据容器**的内容取出，依次追加到列表尾部

**删除元素：**
语法1: ` del 列表[下标] `
语法2：` 列表.pop(下标) ` **相当于取出,可以使用变量保存取出的值**
语法3：` 列表.remove(元素) ` **从前到后，找到了匹配的元素，删除第一个**

**清空列表内容：** ` 列表.clear() `

**统计==某元素==在列表内的数量:**
语法：` 列表.count(元素) `

**统计列表内，有多少元素:**
语法：` len(列表) `

==**返回一个int类型的值**==

**总结：**
![Alt text](img/%E5%88%97%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95.png)

#### 列表的循环遍历
既然数据容器可以存储多个元素，那么，就会有需求从容器内依次取出元素进行操作。
将容器内的元素依次取出进行处理的行为，称之为：**遍历、迭代。**

**while循环：**
![Alt text](img/while%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8.png)

**for循环：**
![Alt text](img/for%E5%BE%AA%E7%8E%AF.png)


**while循环和for循环，都是循环语句，但细节不同：**
- 在循环控制上：
    - while循环可以自定循环条件,并自行控制
    - for循环不可以自定循环条件,只可以一个个从容器内取出数据
- 在无限循环上：
    - while循环可以通过条件控制做到无限循环
    - for循环理论上不可以,因为被遍历的容器容量不是无限的
- 在使用场景上：
    - while循环适用于任何想要循环的场景
    - for循环适用于，遍历数据容器的场景或简单的固定次数循环场景

**for循环更简单，while更灵活
for用于从容器内依次取出元素并处理，while用以任何需要循环的场景**

### 元组：

**元组同列表一样**，都是可以封装多个、不同类型的元素在内。
但是最大的==不同点==在于：==**元组一旦定义完成,就不可修改**==

#### 元组的定义

元组定义：定义元组使用**小括号**，且使用**逗号**隔开各个数据，**数据可以是不同的数据类型**。

```python
# 定义元组字面量
（元素，元素，......，元素）
# 定义元组变量
变量名称 =（元素，元素，......，元素）
# 定义空元组
变量名称 = ()       # 方法1
变量名称 = tuple() # 方法2
```
==**注意：元组只有一个数据，这个数据后面要添加逗号**==

` t1 = ('python',) `

#### 元组的方法：
![Alt text](img/%E5%85%83%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95.png)

**元组的内容不能修改，会报错**
==**例外：元组里的列表可以修改...**==

### 字符串：

#### 字符串的索引：
和其它容器如：列表、元组一样，**字符串也可以通过下标进行访问**
- 从前向后，下标从 0 开始
- 从后向前，下标从 -1 开始

同元组一样， ==**字符串是一个无法修改**== 的数据容器。

#### 字符串的方法：

**字符串的查找：**
` index(字符串) ` 返回 **查找的字符串** 的 **起始索引**

**字符串的替换**
语法：` 字符串.replace(字符串1，字符串2)`
功能：将字符串内的全部：字符串1，替换为字符串2
==**注意：不是修改字符串本身，而是得到了一个新字符串**==

**字符串的分割：**
语法：` 字符串.split（分隔符字符串） `
功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中
==**注意：字符串本身不变，而是得到了一个列表对象**==


**字符串的规整操作（去前后空格）**
语法：` 字符串.strip() `


**字符串的规整操作（去前后指定字符串）**
语法： ` 字符串.strip(字符串) ` 
注意：传入的是 12 其实就是： 1 和 2 都会移除，是按照单个字符。

**统计某个字符出现的次数**
`字符串.count()`

**统计字符串的长度**
`len(字符串)`

![Alt text](img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95.png)

#### 字符串的遍历 
    ......

### 数据容器的序列和切片
==**序列是指：内容连续、有序，可使用下标索引的一类数据容器**==
**列表、元组、字符串，均可以可以视为序列。**

==**切片：从一个序列中，取出一个子序列**==

**序列支持切片，即：==列表、元组、字符串，均支持进行切片操作==**

语法：` 序列[起始下标:结束下标:步长] `
**表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列:**
- 起始下标表示从何处开始，可以留空，留空视作从头开始
- 结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾
- 步长表示，依次取元素的间隔
    - 步长1表示，一个个取元素
    - 步长2表示，每次跳过1个元素取
    - 步长N表示，每次跳过N-1个元素取
    - **步长为负数表示，反向取（注意，起始下标和结束下标也要反向标记）**

此操作不会影响序列本身，因为会创造出一个新的序列

**反转:** ` 序列[::-1] `


### 集合：

**集合：不支持元素的重复，内容无序**

#### 集合的定义：
```python
# 定义集合字面量
{元素，元素，...，元素}
# 定义集合变量
变量名称 = {元素，元素，·，元素}
#定义空集合
变量名称 = set()
```

#### 集合的方法：
首先，**因为集合是无序的，所以集合不支持：下标索引访问**

但是集合和列表一样，是允许修改的，所以我们来看看集合的修改方法。

**添加新元素**
语法：` 集合.dd(元素) ` 将指定元素，添加到集合内
结果：集合本身被修改，添加了新元素

**移除元素**
语法：` 集合.remove(元素) `将指定元素，从集合内移除
结果：集合本身被修改，移除了元素

**从集合中随机取出元素**
语法：` 集合.pop() ` 从集合中随机取出一个元素
结果：会得到一个元素的结果。同时**集合本身被修改，元素被移除**

**清空集合**
语法： ` 集合.clear() `清空集合
结果：集合本身被清空

**取出2个集合的差集**
语法：` 集合1.difference(集合2) ` 取出集合1和集合2的差集（集合1有而集合2没有的)
结果：**得到一个新集金，集合1和集合2不变**

**消除2个集合的差集**
语法： ` 集合1.difference update(集合2) `
功能：对比集合1和集合2，在**集合1内，删除和集合2相同的元素**。
结果：**集合1被修改，集合2不变**

**2个集合合并**
语法：` 集合1.union(集合2)` 
功能：将集合1和集合2组合成新集合
结果：**得到新集合，集合1和集合2不变**

**统计集合的元素数量**
`len(集合) `


![Alt text](img/%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95.png)

#### 集合的遍历

**无法使用 while 遍历，因为无法使用下标**

其他差不多


### 字典

可以按 **Key** 找到 **Value**

#### 字典的定义：
字典的定义:**同样使用{ }，不过存储的元素是一个个的：键值对**
```python
#定义字典字面量
{key:valueg key:value,......key:value}
#定义字典变量
my_dict = {key:vaTue,key:value,......key:value}
#定义空字典
my_dict = {}        # 空字典定义方式1
my_dict = dict()    # 空字典定义方式2
```

**注意：**
- **Key 不能重复，如果重复，也只能覆盖老数据**
- **字典的Key和Value可以是任意数据类型(Key不可为字典)，也就是说==可以嵌套==**

#### 字典的方法：

**新增元素**
语法：`字典[Key] = Value ` **key 要不存在**
结果：字典被修改，新增了元素

**更新元素**
语法：`字典[Key] = Value ` **key 要原本就存在**
结果：字典被修改，更新了元素

**删除元素**
语法：` 字典.pop(Key) `
结果：获得指定 Key 的 Value ,同时字典被修改，指定 Key 的数据被删除

**清空字典**
语法：`字典.clear() `


**获取全部的key**
语法：` 字典.keys() `
结果：得到字典中的全部Key

**获取的这个全部 Key 可以用来循环遍历
不过实际上可以直接用 for 来循环遍历**

**字典不能使用 while 循环遍历**


**统计字典的元素数量**
`len(字典)`

![Alt text](img/%E5%AD%97%E5%85%B8%E7%9A%84%E6%96%B9%E6%B3%95.png)

### 数据容器的总结

![Alt text](img/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%8D%E5%90%8C.png)

### 数据容器的通用操作
首先，在遍历上：
- 5类数据容器都支持for循环遍历
- 列表、元组、字符串支持while循环，集合、字典不支持（无法下标索引)
尽管遍历的形式各有不同，但是，**它们都支持遍历操作。**

除了遍历这个共性外，数据容器可以**通用非常多的功能方法**
` len(容器) `  统计容器的元素个数
` max(容器) `   统计容器的最大元素
` min(容器) `  统计容器的最小元素


**转换**

` list(容器)  ` 将给定容器转换为列表
字符串会变成一个个字符，字典只有 Key 值，失去了 Value

` str(容器)   ` 将给定容器转换为字符串
字典会有Key 和 Value 都正常，基本上变成一长个字符串

` tuple(容器) ` 将给定容器转换为元组
和列表差不多

` set(容器)   ` 将给定容器转换为集合
重复的去重，数据乱序

` dict() `需要键值对才能转换，所以就当不能转

**通用排序**
`sorted(容器,[reverse=True])`
排完变成列表，所有都是
字符串会变成一个个字符，字典只有 Key 值，失去了 Value，也只排列 Key 值

` sorted(容器,reverse=True) `倒排
` sorted(容器) `正排

**字符串比较大小**
**字符串的大小比较主要是通过 ASCII 码表进行比较**

字符串比较大小是按位比较，也就是一位位进行对比，只要有一位大，那么整体就大。

` ab > a `
` abd > abc `
` key2 > key1 `
` abz > abc `






















